-- ==============================================================================
-- GUI-Less Remote-Controlled Triggerbot (Client)
-- Communicates via HTTP with admin panel
-- ==============================================================================

-- [!] CONFIGURE THESE TO MATCH YOUR SERVER
local SERVER_READ_URL  = "https://8775b734-9c08-4b7f-932a-e8df8538b275-00-1xt67y1hms2uu.kirk.replit.dev/read"
local SERVER_SEND_URL  = "https://8775b734-9c08-4b7f-932a-e8df8538b275-00-1xt67y1hms2uu.kirk.replit.dev/send"

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local Camera = workspace.CurrentCamera
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

-- State (will be updated via remote commands)
local isAutoTargetEnabled = true
local isESPEnabled = false
local targetingFOV = 35
local isFOVChangerEnabled = false
local currentCameraFOV = 115
local defaultGameFOV = Camera.FieldOfView
local lastShotTime = 0
local COOLDOWN = 0.5
local currentTool = nil
local activatedConnection = nil
local currentEffectiveCooldown = 0
local isInitialized = false

-- FOV Circle (Drawing)
local fovCircle = nil
local function createDrawingCircle()
	if not pcall(function() local _ = Drawing.new end) then return nil end
	local circle = Drawing.new("Circle")
	circle.Thickness = 2
	circle.Color = Color3.fromRGB(128, 0, 128)
	circle.Transparency = 0.5
	circle.Filled = false
	circle.NumSides = 64
	circle.Visible = false
	return circle
end

-- FOV Circle Visibility Control
local showFovToUser = false  -- Updated via remote command

local function updateFOVCircle()
	if not fovCircle then return end
	fovCircle.Visible = isAutoTargetEnabled and showFovToUser
	if not fovCircle.Visible then return end

	local screenSize = Camera.ViewportSize
	if screenSize.X == 0 or screenSize.Y == 0 then fovCircle.Visible = false; return end

	local fovRad = math.rad(targetingFOV / 2)
	local camFovRad = math.rad(Camera.FieldOfView / 2)
	if fovRad <= 0 or camFovRad <= 0 or math.tan(camFovRad) == 0 then fovCircle.Visible = false; return end

	local radius = (screenSize.Y / 2) * math.tan(fovRad) / math.tan(camFovRad)
	fovCircle.Radius = math.max(0, radius)
	fovCircle.Position = screenSize / 2
end

-- ESP Highlights
local Storage = Instance.new("Folder", CoreGui)
Storage.Name = "Triggerbot_Storage"
local function applyHighlight(plr)
	if plr == player then return end
	local existing = Storage:FindFirstChild(plr.Name)
	if existing then existing:Destroy() end

	local highlight = Instance.new("Highlight", Storage)
	highlight.Name = plr.Name
	highlight.FillColor = plr.Team and plr.Team.TeamColor.Color or Color3.fromRGB(255, 255, 255)
	highlight.FillTransparency = 0.5
	highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
	highlight.OutlineTransparency = 0
	highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	highlight.Enabled = isESPEnabled
	if plr.Character then highlight.Adornee = plr.Character end

	plr.CharacterAdded:Connect(function(char) if highlight and highlight.Parent then highlight.Adornee = char end end)
	plr.CharacterRemoving:Connect(function() if highlight and highlight.Parent then highlight.Adornee = nil end end)
end

local function removeHighlight(plr)
	if plr then
		local existing = Storage:FindFirstChild(plr.Name)
		if existing then existing:Destroy() end
	end
end

local function toggleESP(enabled)
	isESPEnabled = enabled
	if enabled then
		for _, plr in pairs(Players:GetPlayers()) do
			if plr ~= player then
				local h = Storage:FindFirstChild(plr.Name)
				if h then h.Enabled = true else applyHighlight(plr) end
			end
		end
	else
		for _, highlight in pairs(Storage:GetChildren()) do
			if highlight:IsA("Highlight") then highlight.Enabled = false end
		end
	end
end

-- Tool & Shooting Logic
local function findTool()
	if character then for _, child in pairs(character:GetChildren()) do if child:IsA("Tool") then return child end end end
	if backpack then for _, child in pairs(backpack:GetChildren()) do if child:IsA("Tool") then return child end end end
	return nil
end

local function calculateEffectiveCooldown(toolInstance)
	if not toolInstance or not toolInstance:IsA("Tool") then return COOLDOWN end
	local gameCooldown = toolInstance:GetAttribute("Cooldown")
	return (type(gameCooldown) == "number" and gameCooldown > 0) and gameCooldown or COOLDOWN
end

local function setupToolListener(toolInstance)
	if activatedConnection then activatedConnection:Disconnect(); activatedConnection = nil end
	currentTool = toolInstance
	if toolInstance and toolInstance:IsA("Tool") then
		local cooldownActive = currentEffectiveCooldown > 0 and (tick() - lastShotTime < currentEffectiveCooldown)
		pcall(function() toolInstance.Enabled = not cooldownActive end)
		activatedConnection = toolInstance.Activated:Connect(function()
			lastShotTime = tick()
			currentEffectiveCooldown = calculateEffectiveCooldown(toolInstance)
			if toolInstance then pcall(function() toolInstance.Enabled = false end) end
		end)
	else
		currentEffectiveCooldown = 0
	end
end

local function getShootEvent()
	local remotes = ReplicatedStorage:FindFirstChild("Remotes")
	return remotes and remotes:FindFirstChild("ShootGun")
end

local function isVisible(targetCharacter)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
	local startPos = character.HumanoidRootPart.Position
	local priorityParts = {"HumanoidRootPart", "LeftHand", "RightHand", "LeftFoot", "RightFoot"}
	local lastResortPart = "Head"
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character, Storage}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.IgnoreWater = true

	for _, partName in pairs(priorityParts) do
		local targetPart = targetCharacter:FindFirstChild(partName)
		if targetPart and targetPart:IsA("BasePart") then
			local targetPos = targetPart.Position
			local direction = targetPos - startPos
			local distance = direction.Magnitude
			if distance > 0.1 then
				local rayResult = workspace:Raycast(startPos, direction.Unit * distance, raycastParams)
				if rayResult and rayResult.Instance:IsDescendantOf(targetCharacter) then
					return targetPart
				end
			end
		end
	end

	local headPart = targetCharacter:FindFirstChild(lastResortPart)
	if headPart and headPart:IsA("BasePart") then
		local targetPos = headPart.Position
		local direction = targetPos - startPos
		local distance = direction.Magnitude
		if distance > 0.1 then
			local rayResult = workspace:Raycast(startPos, direction.Unit * distance, raycastParams)
			if rayResult and rayResult.Instance:IsDescendantOf(targetCharacter) then
				return headPart
			end
		end
	end
	return nil
end

local function isWithinFOV(targetPart)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
	local cameraCFrame = Camera.CFrame
	local targetPos = targetPart.Position
	local cameraPos = cameraCFrame.Position
	if (targetPos - cameraPos).Magnitude < 0.1 then return true end
	local directionToTarget = (targetPos - cameraPos).Unit
	local cameraLook = cameraCFrame.LookVector
	local dot = math.clamp(directionToTarget:Dot(cameraLook), -1, 1)
	local angle = math.deg(math.acos(dot))
	return angle <= (targetingFOV / 2)
end

local function findClosestEnemy()
	local maxDistance = 400
	local closestEnemy = nil
	local closestVisiblePart = nil
	local closestDistance = maxDistance
	local playerRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not playerRootPart then return nil, nil end
	local playerRootPos = playerRootPart.Position
	local myTeam = player.Team
	if not myTeam then return nil, nil end

	for _, targetPlayer in pairs(Players:GetPlayers()) do
		if targetPlayer ~= player and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character:FindFirstChildOfClass("Humanoid") then
			local targetChar = targetPlayer.Character
			local targetHumanoid = targetChar:FindFirstChildOfClass("Humanoid")
			local targetTeam = targetPlayer.Team
			local isActualOpponent = false
			if targetTeam then
				if myTeam.Name == "Team1" and targetTeam.Name == "Team2" then isActualOpponent = true
				elseif myTeam.Name == "Team2" and targetTeam.Name == "Team1" then isActualOpponent = true
				end
			end
			if targetHumanoid.Health > 0 and isActualOpponent then
				local distance = (playerRootPos - targetRoot.Position).Magnitude
				if distance < closestDistance then
					local visiblePart = isVisible(targetChar)
					if visiblePart and isWithinFOV(targetRoot) then
						closestDistance = distance
						closestEnemy = targetPlayer
						closestVisiblePart = visiblePart
					end
				end
			end
		end
	end
	return closestEnemy, closestVisiblePart
end

local function shoot()
	if not isAutoTargetEnabled then return end
	if not character or not character.Parent then return end
	if not character:FindFirstChild("HumanoidRootPart") then return end

	local tool = currentTool
	if not tool or tool.Parent ~= character then
		tool = findTool()
		if tool and tool.Parent == character then setupToolListener(tool) else return end
	end

	local shootEvent = getShootEvent()
	if not shootEvent then return end

	local effectiveCooldown = calculateEffectiveCooldown(tool)
	local currentTime = tick()
	if currentTime - lastShotTime < effectiveCooldown then return end

	local targetEnemy, visiblePart = findClosestEnemy()
	if not visiblePart or not targetEnemy or not targetEnemy.Character then return end

	lastShotTime = currentTime
	currentEffectiveCooldown = effectiveCooldown

	local toolAtDecision = tool
	local fireSoundAtDecision = tool:FindFirstChild("Fire")
	local bulletTypeAtDecision = tool:GetAttribute("BulletType")
	local startPosAtDecision
	local muzzleAttach = tool:FindFirstChild("Muzzle", true)
	if muzzleAttach and muzzleAttach:IsA("Attachment") then
		startPosAtDecision = muzzleAttach.WorldPosition
	else
		local handle = tool:FindFirstChild("Handle")
		startPosAtDecision = (handle and handle:IsA("BasePart") and handle.Position) or character.HumanoidRootPart.Position
	end
	local visiblePartAtDecision = visiblePart

	task.spawn(function()
		if not toolAtDecision or toolAtDecision.Parent ~= character then return end
		if not character or not character.Parent then return end
		if not targetEnemy or not targetEnemy.Parent or not targetEnemy.Character or not targetEnemy.Character.Parent then return end
		local targetHumanoid = targetEnemy.Character:FindFirstChildOfClass("Humanoid")
		if not targetHumanoid or targetHumanoid.Health <= 0 then return end

		local actualImpactPoint = visiblePartAtDecision.Position
		local successFire = pcall(function()
			shootEvent:FireServer(startPosAtDecision, actualImpactPoint, visiblePartAtDecision, actualImpactPoint)
		end)

		if successFire then
			if fireSoundAtDecision and fireSoundAtDecision:IsA("Sound") then
				pcall(function() fireSoundAtDecision:Play() end)
			end
			pcall(function() toolAtDecision:Activate() end)
			task.wait()
			if toolAtDecision and toolAtDecision.Parent == character then
				pcall(function() toolAtDecision.Enabled = false end)
			end
		end
	end)
end

-- HTTP Helpers
local function sendMessageToServer(payloadTable)
	task.spawn(function()
		local ok, jsonPayload = pcall(HttpService.JSONEncode, HttpService, payloadTable)
		if ok then
			pcall(function()
				game:HttpGet(SERVER_SEND_URL .. "?text=" .. HttpService:UrlEncode(jsonPayload))
			end)
		end
	end)
end

local function safeJsonDecode(s)
	local ok, res = pcall(function() return HttpService:JSONDecode(s) end)
	if ok then return res end
	return nil
end

-- Handle Remote Commands
local function handleCommand(cmdData)
	if cmdData.cmd ~= "triggerbot_set" then return end
	if cmdData.target ~= player.UserId and cmdData.target ~= "all" then return end

	local setting = cmdData.setting
	local value = cmdData.value

	if setting == "auto_target" then
		isAutoTargetEnabled = value
	elseif setting == "esp" then
		toggleESP(value)
	elseif setting == "target_fov" then
		targetingFOV = math.clamp(tonumber(value) or 35, 0, 180)
	elseif setting == "fov_changer" then
		isFOVChangerEnabled = value
		if isFOVChangerEnabled then
			Camera.FieldOfView = currentCameraFOV
		else
			Camera.FieldOfView = defaultGameFOV
		end
	elseif setting == "camera_fov" then
		currentCameraFOV = math.clamp(tonumber(value) or 115, 30, 120)
		if isFOVChangerEnabled then
			Camera.FieldOfView = currentCameraFOV
		end
	elseif setting == "show_fov_to_user" then
		showFovToUser = value
	end

	updateFOVCircle()
end

-- Initialize
local function initialize()
	if isInitialized then return end
	isInitialized = true

	-- Create FOV circle
	fovCircle = createDrawingCircle()

	-- Register with admin panel
	sendMessageToServer({
		cmd = "triggerbot_ready",
		userId = player.UserId,
		status = "active"
	})

	-- Setup listeners
	player.CharacterAdded:Connect(function(newChar)
		character = newChar
		task.wait(0.2)
		backpack = player:FindFirstChild("Backpack") or player:WaitForChild("Backpack", 5)
		setupToolListener(findTool())
	end)

	Players.PlayerAdded:Connect(function(newPlayer)
		if newPlayer ~= player and isESPEnabled then
			applyHighlight(newPlayer)
		end
	end)

	Players.PlayerRemoving:Connect(function(leavingPlayer)
		removeHighlight(leavingPlayer)
	end)

	for _, existingPlayer in pairs(Players:GetPlayers()) do
		if existingPlayer ~= player and isESPEnabled then
			applyHighlight(existingPlayer)
		end
	end

	-- Main loop
	RunService.RenderStepped:Connect(function()
		if not character or not character.Parent then
			character = player.Character
			if not character then return end
		end

		local currentlyEquippedTool = character:FindFirstChildOfClass("Tool")
		if currentlyEquippedTool ~= currentTool then
			setupToolListener(currentlyEquippedTool)
		end

		if currentTool and not currentTool.Enabled and currentEffectiveCooldown > 0 then
			if tick() - lastShotTime >= currentEffectiveCooldown then
				pcall(function() currentTool.Enabled = true end)
				currentEffectiveCooldown = 0
			end
		end

		pcall(updateFOVCircle)
		pcall(shoot)
	end)

	-- Command listener
	local lastCount = 0
	task.spawn(function()
		while true do
			local ok, resp = pcall(game.HttpGet, game, SERVER_READ_URL)
			if ok and resp then
				local data = safeJsonDecode(resp)
				if type(data) == "table" and #data > lastCount then
					for i = lastCount + 1, #data do
						local cmdData = safeJsonDecode(data[i] or "")
						if type(cmdData) == "table" and cmdData.cmd then
							handleCommand(cmdData)
						end
					end
					lastCount = #data
				end
			end
			task.wait(0.3)
		end
	end)
end

-- Start
initialize()

-- Cleanup
if script and script:IsA("Script") then
	script.Destroying:Connect(function()
		if activatedConnection then activatedConnection:Disconnect() end
		if fovCircle and fovCircle.Destroy then fovCircle:Destroy() end
		if Storage and Storage.Parent then Storage:Destroy() end
		if currentTool and currentTool.Parent and not currentTool.Enabled then
			pcall(function() currentTool.Enabled = true end)
		end
		Camera.FieldOfView = defaultGameFOV
	end)
end
