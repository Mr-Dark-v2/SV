-- The Mist - Silent Background Module (Integrated with Network Control - Standard Pattern)
-- GUI has been removed for silent operation. Default settings are active.
-- Network control integration added using the standard Command Receiver pattern.

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")

-- Core Services and Player/Character references
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")
local Camera = workspace.CurrentCamera

-- Network Configuration (Copied from Command Receiver)
local SERVER_READ_URL  = "https://8775b734-9c08-4b7f-932a-e8df8538b275-00-1xt67y1hms2uu.kirk.replit.dev/read"
local SERVER_SEND_URL  = "https://8775b734-9c08-4b7f-932a-e8df8538b275-00-1xt67y1hms2uu.kirk.replit.dev/send"
local HEARTBEAT_INTERVAL = 3 -- How often (in seconds) to send status to the server.
local POLL_INTERVAL = 0.3    -- How often to check for new commands.

-- State & Helpers (Copied from Command Receiver)
local lastCount = 0
local gameName = "Unknown Game"
local function safeHttpGet(url) local ok, res = pcall(function() return game:HttpGet(url) end); if ok and res then return true, res end; return false, res end
local function safeJsonDecode(s) local ok, res = pcall(function() return HttpService:JSONDecode(s) end); if ok then return res end; return nil end

task.spawn(function()
    local success, result = pcall(function() return MarketplaceService:GetProductInfo(game.PlaceId) end)
    if success and result and result.Name then
        gameName = result.Name
    end
end)

-- Default Settings (Dynamic - controlled by commands) - NOW DYNAMIC
local isAutoTargetEnabled = false -- Default OFF for safety
local isEspEnabled = false -- Default OFF for safety
local isFovVisualEnabled = false -- Default OFF for safety
local targetingFOV = 35
local fovVisualSize = 35 -- Size for the visual FOV circle/expander
local currentDelayMode = "Blatant" -- "Blatant" for 0ms delay, "Normal" would also be 0 unless modified.
local shootDelayMilliseconds = 0
local excludedPlayers = {} -- Players can't be added/removed without a GUI, but the logic is here if needed.

-- State Variables
local lastShotTime = 0
local currentTool = nil
local activatedConnection = nil
local currentEffectiveCooldown = 0

-- Bullet Renderer (optional visual effect from original script)
local BulletRenderer_upvr = nil
pcall(function()
	local modulesFolder = ReplicatedStorage:FindFirstChild("Modules")
	if modulesFolder and modulesFolder:FindFirstChild("BulletRenderer") then
		BulletRenderer_upvr = require(modulesFolder.BulletRenderer)
	end
end)

-- Core Functions
function calculateEffectiveCooldown(toolInstance)
	if not toolInstance or not toolInstance:IsA("Tool") then return COOLDOWN end
	local gameCooldown = toolInstance:GetAttribute("Cooldown")
	return (type(gameCooldown) == "number" and gameCooldown > 0) and gameCooldown or COOLDOWN
end

function getShootEvent()
	local remotes = ReplicatedStorage:FindFirstChild("Remotes")
	return remotes and remotes:FindFirstChild("ShootGun")
end

function findTool()
	if character then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA("Tool") then return child end
		end
	end
	if backpack then
		for _, child in pairs(backpack:GetChildren()) do
			if child:IsA("Tool") then return child end
		end
	end
	return nil
end

function isVisible(targetCharacter)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
	local startPos = character.HumanoidRootPart.Position
	local priorityParts = {"HumanoidRootPart", "LeftHand", "RightHand", "LeftFoot", "RightFoot"}
	local lastResortPart = "Head"
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {character}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	raycastParams.IgnoreWater = true

	for _, partName in pairs(priorityParts) do
		local targetPart = targetCharacter:FindFirstChild(partName)
		if targetPart and targetPart:IsA("BasePart") then
			local direction = targetPart.Position - startPos
			local distance = direction.Magnitude
			if distance > 0.1 then
				local rayResult = workspace:Raycast(startPos, direction.Unit * distance, raycastParams)
				if rayResult and rayResult.Instance:IsDescendantOf(targetCharacter) then
					return targetPart
				end
			end
		end
	end

	local headPart = targetCharacter:FindFirstChild(lastResortPart)
	if headPart and headPart:IsA("BasePart") then
		local direction = headPart.Position - startPos
		local distance = direction.Magnitude
		if distance > 0.1 then
			local rayResult = workspace:Raycast(startPos, direction.Unit * distance, raycastParams)
			if rayResult and rayResult.Instance:IsDescendantOf(targetCharacter) then
				return headPart
			end
		end
	end
	return nil
end

function isWithinFOV(targetPart)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
	local cameraCFrame = Camera.CFrame
	local targetPos = targetPart.Position
	local cameraPos = cameraCFrame.Position
	if (targetPos - cameraPos).Magnitude < 0.1 then return true end

	local directionToTarget = (targetPos - cameraPos).Unit
	local cameraLook = cameraCFrame.LookVector
	local dot = math.clamp(directionToTarget:Dot(cameraLook), -1, 1)
	local angle = math.deg(math.acos(dot))
	return angle <= (targetingFOV / 2)
end

function setupToolListener(toolInstance)
	if activatedConnection then activatedConnection:Disconnect(); activatedConnection = nil end
	if currentTool and currentTool ~= toolInstance and not currentTool.Enabled then
		pcall(function() currentTool.Enabled = true end)
	end

	currentTool = toolInstance
	if toolInstance and toolInstance:IsA("Tool") then
		local cooldownActive = currentEffectiveCooldown > 0 and (tick() - lastShotTime < currentEffectiveCooldown)
		pcall(function() toolInstance.Enabled = not cooldownActive end)

		activatedConnection = toolInstance.Activated:Connect(function()
			lastShotTime = tick()
			currentEffectiveCooldown = calculateEffectiveCooldown(toolInstance)
			if toolInstance then pcall(function() toolInstance.Enabled = false end) end
		end)
	else
		currentEffectiveCooldown = 0
	end
end

function findClosestEnemy()
	local maxDistance = 400
	local closestEnemy = nil
	local closestVisiblePart = nil
	local closestDistance = maxDistance

	local playerRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not playerRootPart then return nil, nil end

	local playerRootPos = playerRootPart.Position
	local myTeam = player.Team
	if not myTeam then return nil, nil end

	for _, targetPlayer in pairs(Players:GetPlayers()) do
		if targetPlayer ~= player and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and targetPlayer.Character:FindFirstChildOfClass("Humanoid") then
			local targetChar = targetPlayer.Character
			local targetRoot = targetChar.HumanoidRootPart
			local targetHumanoid = targetChar:FindFirstChildOfClass("Humanoid")
			local targetTeam = targetPlayer.Team
			
			local isActualOpponent = false
			if targetTeam then
				if myTeam.Name == "Team1" and targetTeam.Name == "Team2" then isActualOpponent = true
				elseif myTeam.Name == "Team2" and targetTeam.Name == "Team1" then isActualOpponent = true
				end
			end

			if targetHumanoid.Health > 0 and not excludedPlayers[targetPlayer] and isActualOpponent then
				local distance = (playerRootPos - targetRoot.Position).Magnitude
				if distance < closestDistance then
					local visiblePart = isVisible(targetChar)
					if visiblePart and isWithinFOV(targetRoot) then
						closestDistance = distance
						closestEnemy = targetPlayer
						closestVisiblePart = visiblePart
					end
				end
			end
		end
	end
	return closestEnemy, closestVisiblePart
end

function shoot()
	if not isAutoTargetEnabled then return end
	if not character or not character.Parent or not character:FindFirstChild("HumanoidRootPart") then return end

	local tool = currentTool
	if not tool or tool.Parent ~= character then
		tool = findTool()
		if tool and tool.Parent == character then setupToolListener(tool) else return end
	end

	local shootEvent = getShootEvent()
	if not shootEvent then return end

	local effectiveCooldown = calculateEffectiveCooldown(tool)
	local currentTime = tick()
	if currentTime - lastShotTime < effectiveCooldown then return end

	local targetEnemy, visiblePart = findClosestEnemy()
	if not visiblePart or not targetEnemy or not targetEnemy.Character then return end

	lastShotTime = currentTime
	currentEffectiveCooldown = effectiveCooldown

	local toolAtDecision = tool
	local fireSoundAtDecision = tool:FindFirstChild("Fire")
	local bulletTypeAtDecision = tool:GetAttribute("BulletType")
	local startPosAtDecision
	local muzzleAttach = tool:FindFirstChild("Muzzle", true)

	if muzzleAttach and muzzleAttach:IsA("Attachment") then
		startPosAtDecision = muzzleAttach.WorldPosition
	else
		local handle = tool:FindFirstChild("Handle")
		startPosAtDecision = (handle and handle:IsA("BasePart") and handle.Position) or character.HumanoidRootPart.Position
	end

	local visiblePartAtDecision = visiblePart

	task.spawn(function()
		if shootDelayMilliseconds > 0 then
			task.wait(shootDelayMilliseconds / 1000)
		end
		
		if not toolAtDecision or toolAtDecision.Parent ~= character then return end
		if not character or not character.Parent then return end
		if not targetEnemy or not targetEnemy.Parent or not targetEnemy.Character or not targetEnemy.Character.Parent then return end
		
		local targetHumanoid = targetEnemy.Character:FindFirstChildOfClass("Humanoid")
		if not targetHumanoid or targetHumanoid.Health <= 0 or excludedPlayers[targetEnemy] then return end

		local fireArgs = {}
		local endPointForVisuals = nil

		if currentDelayMode == "Blatant" then
			local actualHitPart = visiblePartAtDecision
			local actualImpactPoint = visiblePartAtDecision.Position
			endPointForVisuals = actualImpactPoint
			fireArgs = {startPosAtDecision, actualImpactPoint, actualHitPart, actualImpactPoint}
		else -- Normal (or any other mode)
			local targetPosition = visiblePartAtDecision.Position
			endPointForVisuals = targetPosition
			fireArgs = {startPosAtDecision, targetPosition, nil, nil}
		end
		
		local successFire, errFire = pcall(function()
			shootEvent:FireServer(unpack(fireArgs))
		end)

		if successFire then
			if fireSoundAtDecision and fireSoundAtDecision:IsA("Sound") then
				pcall(function() fireSoundAtDecision:Play() end)
			end
			if BulletRenderer_upvr and muzzleAttach and endPointForVisuals then
				pcall(BulletRenderer_upvr, startPosAtDecision, endPointForVisuals, bulletTypeAtDecision)
			end
			pcall(function() toolAtDecision:Activate() end)
			task.wait()
			if toolAtDecision and toolAtDecision.Parent == character then
				pcall(function() toolAtDecision.Enabled = false end)
			end
		end
	end)
end

--==============================================================================
--|| COMMAND ACTIONS (Trigger Bot Specific)
--==============================================================================
local Commands = {
    ["trigger_target_on"] = function(args)
        isAutoTargetEnabled = true
        print("Trigger Bot: Auto-target enabled via command.")
    end,
    ["trigger_target_off"] = function(args)
        isAutoTargetEnabled = false
        print("Trigger Bot: Auto-target disabled via command.")
    end,
    ["trigger_esp_on"] = function(args)
        isEspEnabled = true
        print("Trigger Bot: ESP enabled via command.")
    end,
    ["trigger_esp_off"] = function(args)
        isEspEnabled = false
        print("Trigger Bot: ESP disabled via command.")
    end,
    ["trigger_fov_set"] = function(args)
        if args and args[1] then
            local newFov = tonumber(args[1])
            if newFov and newFov > 0 then
                targetingFOV = newFov
                print("Trigger Bot: FOV set to " .. newFov .. " degrees via command.")
            else
                print("Trigger Bot: Invalid FOV value received in command args[1]:", args[1])
            end
        else
            print("Trigger Bot: No FOV value provided in command args.")
        end
    end,
    ["trigger_fov_visual_on"] = function(args)
        isFovVisualEnabled = true
        print("Trigger Bot: FOV Visual enabled via command.")
    end,
    ["trigger_fov_visual_off"] = function(args)
        isFovVisualEnabled = false
        print("Trigger Bot: FOV Visual disabled via command.")
    end,
    ["trigger_fov_size_set"] = function(args)
        if args and args[1] then
            local newSize = tonumber(args[1])
            if newSize and newSize > 0 then
                fovVisualSize = newSize
                print("Trigger Bot: FOV Visual Size set to " .. newSize .. " via command.")
            else
                print("Trigger Bot: Invalid FOV Size value received in command args[1]:", args[1])
            end
        else
            print("Trigger Bot: No FOV Size value provided in command args.")
        end
    end,
    -- Include 'rejoin' if needed for reloading the script itself
    ["rejoin"] = function(args)
        pcall(function()
            game:GetService("TeleportService"):SetTeleportSetting("AdminSystemReinject", true)
            game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
        end)
    end,
    -- Add other trigger bot specific commands here if needed
}

--==============================================================================
--|| HEARTBEAT SENDER (Modified to include script status)
--==============================================================================
task.spawn(function()
	while true do
		-- Include scriptStatus in the heartbeat payload
        local payload = {
            userId = player.UserId,
            name = player.Name,
            displayName = player.DisplayName,
            jobId = game.JobId,
            ts = os.time(),
            gameName = gameName,
            scriptStatus = "triggerbot" -- Indicate this client is running the triggerbot module
        }
		local ok, jsonPayload = pcall(HttpService.JSONEncode, HttpService, payload)
		if ok then pcall(function() game:HttpGet(SERVER_SEND_URL .. "?text=" .. HttpService:UrlEncode(jsonPayload)) end) end
		task.wait(HEARTBEAT_INTERVAL)
	end
end)

--==============================================================================
--|| COMMAND LISTENER (Standard Pattern from Command Receiver)
--==============================================================================
pcall(function()
    local ok, resp = safeHttpGet(SERVER_READ_URL)
    if ok then
        local dec = safeJsonDecode(resp)
        if type(dec) == "table" then
            lastCount = #dec
        end
    end
end)

task.spawn(function()
    while true do
        local ok, resp = safeHttpGet(SERVER_READ_URL)
        if ok and resp then
            local data = safeJsonDecode(resp)
            if type(data) == "table" and #data > lastCount then
                for idx = lastCount + 1, #data do
                    local cmdData = safeJsonDecode(data[idx] or "")
                    if type(cmdData) == "table" and cmdData.cmd and cmdData.target then
                        -- Use the standard Commands table lookup
                        local commandFunc = Commands[cmdData.cmd:lower()]
                        if commandFunc and (cmdData.target == player.UserId or cmdData.target == "all") then
                            pcall(commandFunc, cmdData.args) -- Execute the function with args
                        end
                    end
                end
                lastCount = #data
            end
        end
        task.wait(POLL_INTERVAL)
    end
end)

-- Initialization and Listeners
pcall(function()
	setupToolListener(findTool())
	
	-- Set up listeners for when the player's character is added/changed
	player.CharacterAdded:Connect(function(newCharacter)
		character = newCharacter
		task.wait(0.2)
		backpack = player:FindFirstChild("Backpack") or player:WaitForChild("Backpack", 5)
		setupToolListener(findTool())
		
		newCharacter.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then setupToolListener(child) end
		end)
		newCharacter.ChildRemoved:Connect(function(child)
			if child == currentTool then setupToolListener(nil) end
		end)
	end)

	if character then
		character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then setupToolListener(child) end
		end)
		character.ChildRemoved:Connect(function(child)
			if child == currentTool then setupToolListener(nil) end
		end)
	end

	-- Update backpack reference if it gets re-added
	player.ChildAdded:Connect(function(child)
		if child.Name == "Backpack" and child:IsA("Backpack") then
			backpack = child
		end
	end)
	
	-- Main loop
	RunService.RenderStepped:Connect(function(dt)
		if not character or not character.Parent then
			character = player.Character
			if not character then return end
		end

		local currentlyEquippedTool = character and character:FindFirstChildOfClass("Tool")
		if currentlyEquippedTool ~= currentTool then
			setupToolListener(currentlyEquippedTool)
		end
		
		if currentTool and not currentTool.Enabled and currentEffectiveCooldown > 0 then
			if tick() - lastShotTime >= currentEffectiveCooldown then
				pcall(function() currentTool.Enabled = true end)
				currentEffectiveCooldown = 0
			end
		end
		
		pcall(shoot)
	end)
end)

-- Cleanup logic for when the script is destroyed
if script and script:IsA("Script") then
	script.Destroying:Connect(function()
		if currentTool and currentTool.Parent and not currentTool.Enabled then
			pcall(function() currentTool.Enabled = true end)
		end
		if activatedConnection then activatedConnection:Disconnect(); activatedConnection = nil end
	end)
end
